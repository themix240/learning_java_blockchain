package node.core;

import node.networking.ClientNetworkingLogic;
import node.utils.BlockchainUtils;
import utils.blockchain.Transaction;
import utils.blockchain.User;

import java.io.*;
import java.security.*;
import java.util.Arrays;
import java.util.List;

import static node.utils.BlockchainUtils.getWallet;

/**
 * Class implements all logic needed to handle requests from clients.
 * It only implements logic without networking part.
 * Networking part is implemented in {@link ClientNetworkingLogic}
 */
public class ClientLogic {
    private final List<User> users;

    private User user = null;

    private final String path;
    private final Blockchain bc;

    /**
     * Constructor
     * @param users
     * @param bc
     * @param path
     */
    public ClientLogic(List<User> users, Blockchain bc, String path) {
        this.users = users;
        this.bc = bc;
        this.path = path;
    }

    /**
     * Checks if username is already taken. If not register new user.
     * Saves user data on file specified in constructor.
     * @param username username must be unique.
     * @param publicKey generated publicKey for user.
     * @return <code>true</code> if username is not taken. <code>false</code> otherwise.
     */
    public boolean register(String username, PublicKey publicKey) {
        if (findUser(username) == null) {
            User usr = new User(username, publicKey);
            saveUser(usr);
            return true;
        } else return false;
    }

    /**
     * Adds user to users list.
     * Calls saving users to file.
     * @param userToSave user which will be saved.
     */
    public void saveUser(User userToSave) {
        users.add(userToSave);
        saveChanges();
    }

    /**
     * Saves list of users.
     * If directory and file specified in path not exists method will create them.
     */
    public void saveChanges() {
        File f = new File(path);
        try {
            if (!f.exists()) {
                f.getParentFile().mkdirs();
                f.createNewFile();
            }
            FileOutputStream fileOutputStream = new FileOutputStream(f);
            ObjectOutputStream outputStream1 = new ObjectOutputStream(fileOutputStream);
            outputStream1.writeObject(users);
            outputStream1.close();
            fileOutputStream.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Gets amount of currency at user wallet.
     * @return
     */
    public int calculateWallet() {
        return getWallet(user.getPublicKey(), bc.getBlocks());
    }

    /**
     * Checks if user have selected amount at his wallet and if amount is non-negative value.
     * @param selectedUser user which tries to send transaction.
     * @param amount amount of currency to
     * @return <code>true</code> if transaction is possible; <code>false</code> otherwise.
     */
    public boolean isTransactionPossible(String selectedUser, int amount)  {
        User r = findUser(selectedUser);
        assert r != null;
        Transaction t = new Transaction(user.getPublicKey(), r.getPublicKey(), amount);
        int wallet = (BlockchainUtils.getWallet(user.getPublicKey(), bc.getBlocks()));
        return amount >= 0 && wallet >= amount;
    }

    /**
     * Checks if user correctly decrypted challenge sent by node.
     * It requires private key to decrypt challenge encrypted with public key.
     * @param username username of user who tries to log in.
     * @param challenge original generated byte array sent to client (before encryption).
     * @param decrypted decrypted byte array by user.
     * @return if decrypted byte array is the same as original challenge array <code>true</code>;
     * <code>false</code> otherwise.
     */
    public boolean login(String username, byte[] challenge, byte[] decrypted)  {
        user = findUser(username);
        assert user != null;
        if (user.getUsername().equals(username)) {
            return Arrays.equals(challenge, decrypted);
        }
        return false;
    }

    /**
     * Returns user connected to this node.
     * @return connected user.
     */
    public User getUser() {
        return user;
    }

    /**
     * Checks if user with given username exists in user list.
     * @param username username to check
     * @return Existing user with this username or null if user with this username does not exists.
     */
    public User findUser(String username) {
        for (User u : users) {
            if (username.equals(u.getUsername())) {
                return u;
            }
        }
        return null;
    }
}
